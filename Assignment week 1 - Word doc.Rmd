---
title: "Last chance"
output: word_document
date: "2023-03-13"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}

#install.packages('plyr', repos = "http://cran.us.r-project.org")
#install.packages("r package", repos = "http://cran.us.r-project.org")

#Task 1 - Literature

#2a. What is the medically relevant insight from the article?

#In this article the authors proposed an approach for detecting communities from a genetic network constructed on the basis of coexpression properties. 
#They developed a novel metric, the exclusively expressed index (EEI), that identifies mutually exclusive gene pairs from sparse scRNA-seq data. 
#Findings showed that EEI is effective for detecting mutually exclusive gene sets, while maintaining robustness against a low sequencing depth and improve the sensitivity of the classification of single cells. 
#The results suggest that exclusive expression can be introduced to identify intercell-type heterogeneity based on the feature matrix.
#Authors applied their methods to glioblastoma scRNA-seq data and found that gene communities were partially conserved after serum stimulation despite a considerable number of differentially expressed genes
#Glioblastoma is an heterogeneous tumor, and since their methods improve the sensitivity of the identification of cell-to-cell heterogeneity, this can serve as a tool in multiple other contexts in the single-cell analysis field, complementing existing approaches and providing new biological insights, even for large, sparse dataset.

#2b. Which genomics technology/ technologies were used?

#The authors used scRNA-seq technology.
#To evaluate the performance of EEI and the community detection of coexpression networks they applied their method on six scRNA-seq datasets.
# They generated glioblastoma scRNA-seq data from stem-like cells that were collected at 0 and 12 hours before and after the addition of serum
# They used 5 more already published scRNA-seq data from: Human ES progenitor, Human ESC-derived neuron, Mouse cortex, PBMC CELseq2, PBMC MARSseq 

#They evaluated the effectiveness of EEI compared to four existing methods: the Pearson correlation coefficient, minet, GENIE3 and PIDC. 
#They evaluated the performance of EEI on the basis of the area under the precision-recall curve (AUPR) and average precision. To validate the performance for clustering of single cells, they adopted the Adjusted Rand Index (ARI) and the silhouette coefficient. 
#ARI measures the similarity between predicted and true cluster labels and ranges from 0.0 to 1.0. The silhouette coefficient measures the cluster cohesion and separation and ranges from –1.0 to 1.0.

#3a. List and explain at least three questions/ hypotheses you can think of that extend the analysis presented in the paper.

#1 The authors' novel metric EEI was applied to a newly generated glioblastoma scRNA-seq dataset. To evaluate the performance it would be very interesting to be applied in multiple highly heterogeneous samples, for example human cortex from Alzheimers' patients (different disease stages - different inflammation levels).

#2 The PBMC CELseq2, PBMC MARSseq and human ES datasets were generated by CELseq2, MARSseq and Smartseq2 protocols, not by a droplet-based protocol, they contained sufficient read counts. 
#In most cases, clustering with EEI displayed distinct clusters of cell types in these datasets. This means that EEI is effective not only for sparse scRNA-seq data but also for data with a sufficient sequencing depth. 
#Thus, EEI enables to capture the exclusive expression between two genes displaying intercelltype heterogeneity. It would be interesting to observe if this can be applied to check intracell-type heterogeneity.

#3 The fact that the authors used scRNA-seq data from samples with different number of cells as well as different sequencing depth shows the robustness of this study and that the developed metric that can be aplied across multiple samples. It is still interesting if this tool can be used in clinical samples derived from patients and not cultured glioblastoma stem-like cells (GSCs). That would exclude any culturing-enriching bias.


#if (!require("BiocManager", quietly = TRUE))
 # install.packages("BiocManager")
#BiocManager::install(version = "3.16")


#Task 4 - R basic operations

#1
sqrt(10)

#2
log2(32)

#3
#sum(1:1000)

#4
x= c(2:1000)
#x
a=x[lapply(x, "%%", 2) == 0]
#a
#sum(a)

#5
#The formula for the number of independent pairwise comparisons is k(k-1)/2, where k is the number of conditions

100*(100-1)/2

#6
?combn
triples= combn(100,3)
sum(triples)


#Task 5

#1
data(CO2)
#CO2

#2
help(CO2)
#CO2
#Carbon Dioxide Uptake in Grass Plants
#The CO2 data frame has 84 rows and 5 columns of data from an experiment on the cold tolerance of the grass species Echinochloa crus-galli.

#3

mean(CO2$uptake[CO2$Type=="Quebec"])
median(CO2$uptake[CO2$Type=="Quebec"])

mean(CO2$uptake[CO2$Type=="Mississippi"])
median(CO2$uptake[CO2$Type=="Mississippi"])

#Task 6

#1
vector = c(1, 2, 2, 4, 6, 9)
mean(vector)/median(vector)

#2

a=vector[!vector %in% c(min(vector), max(vector))]
mean(a)

#3
#R pipes (represented by the %>% operator) are used to chain multiple operations in sequence
#Don't use pipes when:
#Pipes are long (create intermediate objects so you can easily check intermediate results)
#You have multiple inputs or outputs
#You have a complex dependency structure, pipes will yield confusing code since they are fundamentally linear

#4
#Takes care of repetitive tasks
#Can often replace loops and are claimed to be faster
#apply() Applies a function to each row or column of a data.frame, matrix (or any dimension of a array).
#lapply() for lists…output as list
#sapply() for lists…output simplified
#tapply() for vectors (groupwise to a variable)

#Task 7

#install.packages("remotes")
library(remotes)
#install_url("http://emotion.utu.fi/wp-content/uploads/2019/11/nummenmaa_1.0.tar.gz",dependencies=TRUE)

setwd("/Users/aphroditedemetriou/Library/CloudStorage/OneDrive-KarolinskaInstitutet/Mac/Documents/PhD/10. KI PhD Courses/Bioinformatics - UT")

mg=read.csv("/Users/aphroditedemetriou/Library/CloudStorage/OneDrive-KarolinskaInstitutet/Mac/Documents/PhD/10. KI PhD Courses/Bioinformatics - UT/magic_guys.csv")
#mg

#1

mg_only_sith=mg[!mg$species=="jedi", ]
#mg_only_sith

mg_only_jedi=mg[!mg$species=="sith", ]
#mg_only_jedi

#histograms

png(file = "histograms1.png", width=1600, height=1167) #save it as png, it is used best for figures
par(mfrow=c(1,2)) #creates the two graphs next to each other
hist(mg_only_jedi$length, breaks=25, main="Jedi height")
hist(mg_only_sith$length, breaks=25, main="Sith height")
title('Distribution of body heights',outer=TRUE)
dev.off() #closes the active device (the png file) and returns to the default mode of presenting graphics on-screen


pdf(file = "histograms2.pdf") #save it as pdf, it is used best for documents
par(mfrow=c(1,2)) #creates the two graphs next to each other
hist(mg_only_jedi$length, breaks=25, main="Jedi height")
hist(mg_only_sith$length, breaks=25, main="Sith height")
dev.off() #closes the active device (the pdf file) 

svg(file = "histograms3.svg") #save it as svg, svg files are used for web graphics like logos, illustrations, and charts
par(mfrow=c(1,2)) #creates the two graphs next to each other
hist(mg_only_jedi$length, breaks=25, main="Jedi height")
hist(mg_only_sith$length, breaks=25, main="Sith height")
dev.off() #closes the active device (the svg file)

#install.packages("ggplot2")
library(ggplot2)
ggplot(mg, aes(x=length)) + geom_histogram() #histogram using ggplot


#boxplots
png(file = "boxplots.png", width=1600, height=1167) #creates a png file
par(mfrow=c(1,2)) #creates the two graphs next to each other
boxplot(mg_only_jedi$length,horizontal=TRUE, main="Jedi height")
boxplot(mg_only_sith$length, horizontal=TRUE, main="Sith height")
dev.off() #closes the active device (the png file)

ggplot(data = mg, mapping = aes(x = species, y = length)) +
  geom_boxplot() #creates the boxplot but with ggplot
ggplot(data = mg, mapping = aes(x = species, y = length)) +
  geom_boxplot(alpha = 0) +
  geom_jitter(alpha = 0.2, color = "magenta") #example of different visualisation


#2
microarray=read.delim("/Users/aphroditedemetriou/Library/CloudStorage/OneDrive-KarolinskaInstitutet/Mac/Documents/PhD/10. KI PhD Courses/Bioinformatics - UT/microarray_data.tab")
#microarray
#summary(microarray)

#2a
nrow(microarray) #553 rows
ncol(microarray) #1000 columns

#2b
sum(is.na(microarray)) #117826 missing values (NA)

#sapply(microarray, function(x) sum(length(which(is.na(x))))) #finds NA per column
missing=sapply(microarray, function(x) sum(length(which(is.na(x)))))
missing=as.matrix(missing)
missing=cbind(rownames(missing), data.frame(missing, row.names=NULL)) #binds matrices together
colnames(missing)=c("gene", "missing values")
#missing

hist(missing$"missing values", breaks=25, main="Missing values") # to visualize

#2c
percent_missing_ten=colMeans(is.na(missing))
genes_10_percent_missing=names(percent_missing_ten[percent_missing_ten > 0.1])
genes_10_percent_missing
percent_missing_twenty=colMeans(is.na(missing))
genes_20_percent_missing=names(percent_missing_twenty[percent_missing_twenty > 0.2])
genes_20_percent_missing
percent_missing_fifty=colMeans(is.na(missing))
genes_50_percent_missing=names(percent_missing_fifty[percent_missing_fifty > 0.5])
genes_50_percent_missing

#2d

row_means=rowMeans(microarray, na.rm=TRUE)
#row_means
microarray_data_replaced=apply(missing, 2, function(x) {
  x[is.na(x)] = row_means
  x
})
#microarray_data_replaced


#3

#CO2
boxplot(uptake ~ Treatment, data=CO2, breaks=50, frame=F, col=c("blue", "green"),xlab="Plant", main="Uptake by treatment") # We observe the nonchilled plants having higher uptake of CO2 and greater variation on the chilled one 
boxplot(conc ~ Type, data=CO2, breaks=50, frame=F, col=c("blue", "green"),xlab="Plant", main="Conc by Area") # We observe that the Conc is not dependent by the area

#Task 8
#install.packages("tidybiology")
#install.packages("devtools")
#devtools::install_github("hirscheylab/tidybiology")
library(tidybiology)
#install.packages("tidyverse")

#a
library(tidyverse)
data(chromosome)
#chromosome
Summary_statistics=summarise(chromosome,across(c(variations, protein_codinggenes, mi_rna),list(mean, median, max)))
Summary_statistics=as.data.frame(matrix(unlist(Summary_statistics), ncol = 3, byrow = TRUE))
colnames(Summary_statistics)=c("Mean", "Median","Max")
rownames(Summary_statistics)=c("Variations", "Protein-coding genes","miRNA")
Summary_statistics

#8b
library(ggplot2)

Chromosomal_size=ggplot(chromosome)+ aes(x =id , y = length_mm, color = id, size=1) + 
  geom_point(position=position_jitter(w = 0.1,h = 5)) +
  theme_bw() +
  ggtitle("Chromosomal size") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size=12)) +
  theme(axis.title.x = element_text(size=10))+
  theme(axis.title.y = element_text(size=10))+
  theme(plot.title = element_text(hjust = 0.5, size=16))+
  theme(legend.position = "none")
Chromosomal_size

#8c
Chromosomal_num_pcg=ggplot(chromosome)+ aes(x =protein_codinggenes , y = length_mm, color = id, size=1) + 
  geom_point(position=position_jitter(w = 0.1,h = 5)) +
  theme_bw() +
  geom_text(aes(label = id), hjust = 2, vjust = 0)+
  ggtitle("Correlation chromosome size and protein-coding gene count") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size=12)) +
  theme(axis.title.x = element_text(size=10))+
  theme(axis.title.y = element_text(size=10))+
  theme(plot.title = element_text(hjust = 0.5, size=16))+
  theme(legend.position = "none") +
  labs(x = "Number of protein-coding genes", y = "Length in mm")
Chromosomal_num_pcg

Chromosomal_num_miRNA=ggplot(chromosome)+ aes(x =mi_rna , y = length_mm, color = id, size=1) + 
  geom_point(position=position_jitter(w = 0.1,h = 5)) +
  theme_bw() +
  geom_text(aes(label = id), hjust = 2, vjust = 0)+
  ggtitle("Correlation chromosome size and miRNA count") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size=12)) +
  theme(axis.title.x = element_text(size=10))+
  theme(axis.title.y = element_text(size=10))+
  theme(plot.title = element_text(hjust = 0.5, size=16))+
  theme(legend.position = "none") +
  labs(x = "Number of miRNAs", y = "Length in mm")
Chromosomal_num_miRNA

#8d
data(proteins)
proteins
Protein_mass_length=ggplot(proteins)+ aes(x =mass , y = length, color = uniprot_id, size=1) + 
  geom_point(position=position_jitter(w = 0.2,h = 5)) +
  theme_bw() +
  geom_text(aes(label = protein_name), hjust = 1.4, vjust = 0)+
  ggtitle("Correlation chromosome size and miRNA count") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size=12)) +
  theme(axis.title.x = element_text(size=10))+
  theme(axis.title.y = element_text(size=10))+
  theme(plot.title = element_text(hjust = 0.5, size=16))+
  theme(legend.position = "none") +
  labs(x = "Protein mass", y = "Length")
Protein_mass_length

```


## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:


## Including Plots

You can also embed plots, for example:

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
